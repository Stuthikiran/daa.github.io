<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DAA Lab Reflections</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <nav>
            <ul>
                <li><a href="index.html">Back to Portfolio</a></li>
            </ul>
        </nav>
        <h1>DAA Lab Reflections</h1>
    </header>

    <main>
        <div class="section">
            <h2>Key Concepts Learned</h2>
            <ul>
                <li>Time Complexity Analysis</li>
                <li>Binary Search Tree</li>
                <li>DFS and BFS</li>
                <li>Heap</li>
                <li>Sorting</li>
                <li>Pattern Searching</li>
                <li>Graph Algorithms</li>
            </ul>
        </div>

        <div class="section">
            <h2>Challenges in Learning/Understanding the Above Concepts</h2>
            <ul>
                <li><strong>Time Complexity Analysis:</strong> Requires a deep understanding of mathematical notations like Big-O, Theta, and Omega.</li>
                
                <li><strong>Binary Search Tree:</strong> Difficulty in understanding rotations during insertion and deletion operations.
                    <pre>
void insert(Node*& root, int value) {
    if (root == nullptr) {
        root = new Node(value);
        return;
    }
    if (value < root->data) {
        insert(root->left, value);
    } else {
        insert(root->right, value);
    }
    root = balance(root); // Balances the tree (e.g., AVL tree rotations)
}
                    </pre>
                </li>
                
                <li><strong>DFS and BFS:</strong> Requires grasping recursion for DFS and queue-based implementation for BFS.
                    <pre>
// DFS Implementation
void DFS(Graph& g, int start, vector<bool>& visited) {
    visited[start] = true;
    cout << start << " ";
    for (int neighbor : g[start]) {
        if (!visited[neighbor]) {
            DFS(g, neighbor, visited);
        }
    }
}

// BFS Implementation
void BFS(Graph& g, int start) {
    queue<int> q;
    vector<bool> visited(g.size(), false);
    q.push(start);
    visited[start] = true;

    while (!q.empty()) {
        int node = q.front();
        q.pop();
        cout << node << " ";
        for (int neighbor : g[node]) {
            if (!visited[neighbor]) {
                q.push(neighbor);
                visited[neighbor] = true;
            }
        }
    }
}
                    </pre>
                </li>
                
                <li><strong>Heap:</strong> Understanding the heapify process and its application in priority queues.
                    <pre>
void heapify(vector<int>& heap, int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left < n && heap[left] > heap[largest])
        largest = left;

    if (right < n && heap[right] > heap[largest])
        largest = right;

    if (largest != i) {
        swap(heap[i], heap[largest]);
        heapify(heap, n, largest);
    }
}
                    </pre>
                </li>
                
                <li><strong>Sorting:</strong> Choosing between algorithms like QuickSort, MergeSort, or HeapSort for optimal performance.
                    <pre>
// QuickSort Implementation
int partition(vector<int>& arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;

    for (int j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i + 1], arr[high]);
    return i + 1;
}

void quickSort(vector<int>& arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}
                    </pre>
                </li>
                
                <li><strong>Pattern Searching:</strong> Challenges in implementing algorithms like KMP due to preprocessing requirements.
                    <pre>
// KMP Algorithm - Preprocessing
void computeLPSArray(string pattern, int M, int* lps) {
    int len = 0;
    lps[0] = 0;
    int i = 1;

    while (i < M) {
        if (pattern[i] == pattern[len]) {
            len++;
            lps[i] = len;
            i++;
        } else {
            if (len != 0) {
                len = lps[len - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
}
                    </pre>
                </li>
                
                <li><strong>Graph Algorithms:</strong> Modeling real-world problems and understanding shortest path or MST algorithms.
                    <pre>
// Dijkstra's Algorithm
void dijkstra(vector<vector<pair<int, int>>>& graph, int src) {
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    vector<int> dist(graph.size(), INT_MAX);

    pq.push({0, src});
    dist[src] = 0;

    while (!pq.empty()) {
        int u = pq.top().second;
        pq.pop();

        for (auto& neighbor : graph[u]) {
            int v = neighbor.first;
            int weight = neighbor.second;

            if (dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                pq.push({dist[v], v});
            }
        }
    }
}
                    </pre>
                </li>
            </ul>
        </div>

        <div class="section">
            <h2>Challenges in Correlating with Real-World Applications</h2>
            <ul>
                <li><strong>Time Complexity Analysis:</strong> Applying theoretical efficiency to large-scale systems like web servers.</li>
                <li><strong>Binary Search Tree:</strong> Optimizing database search operations using balanced trees like AVL or Red-Black Trees.</li>
                <li><strong>DFS and BFS:</strong> Using these in navigation systems or solving puzzles like mazes.</li>
                <li><strong>Heap:</strong> Applications in job scheduling or real-time priority management.</li>
                <li><strong>Sorting:</strong> Efficiently handling data in e-commerce platforms or search engines.</li>
                <li><strong>Pattern Searching:</strong> Real-world applications in text editors or DNA sequence analysis.</li>
                <li><strong>Graph Algorithms:</strong> Applications in social networks, logistics, and communication networks.</li>
            </ul>
        </div>
    </main>

    <footer>
        <p>Copyright Â© 2025 Stuthi Kiran - All Rights Reserved.</p>
    </footer>
</body>
</html>
