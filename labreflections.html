<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DAA Lab Reflections</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        h1 {
            text-align: center;
        }
        ul {
            list-style-type: disc;
            margin-left: 20px;
        }
        .section {
            margin-bottom: 20px;
        }
        pre {
            background-color: #f4f4f4;
            padding: 10px;
            border: 1px solid #ddd;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <h1>DAA Lab Reflections</h1>

    <div class="section">
        <h2>Key Concepts Learned</h2>
        <ul>
            <li>Time Complexity Analysis</li>
            <li>Binary Search Tree</li>
            <li>DFS and BFS</li>
            <li>Heap</li>
            <li>Sorting</li>
            <li>Pattern Searching</li>
            <li>Graph Algorithms</li>
        </ul>
    </div>

    <div class="section">
        <h2>1. Challenges in Learning/Understanding the Above Concepts</h2>
        <ul>
            <li><strong>Time Complexity Analysis:</strong> Requires a deep understanding of mathematical notations like Big-O, Theta, and Omega.</li>
            <li><strong>Binary Search Tree:</strong> Difficulty in understanding rotations during insertion and deletion operations.</li>
            <li><strong>DFS and BFS:</strong> Requires grasping recursion for DFS and queue-based implementation for BFS.</li>
            <li><strong>Heap:</strong> Understanding the heapify process and its application in priority queues.</li>
            <li><strong>Sorting:</strong> Choosing between algorithms like QuickSort, MergeSort, or HeapSort for optimal performance.</li>
            <li><strong>Pattern Searching:</strong> Challenges in implementing algorithms like KMP due to preprocessing requirements.</li>
            <li><strong>Graph Algorithms:</strong> Modeling real-world problems and understanding shortest path or MST algorithms.</li>
        </ul>
    </div>

    <div class="section">
        <h2>2. Challenges in Correlating with Real-World Applications</h2>
        <ul>
            <li><strong>Time Complexity Analysis:</strong> Applying theoretical efficiency to large-scale systems like web servers.</li>
            <li><strong>Binary Search Tree:</strong> Optimizing database search operations using balanced trees like AVL or Red-Black Trees.</li>
            <li><strong>DFS and BFS:</strong> Using these in navigation systems or solving puzzles like mazes.</li>
            <li><strong>Heap:</strong> Applications in job scheduling or real-time priority management.</li>
            <li><strong>Sorting:</strong> Efficiently handling data in e-commerce platforms or search engines.</li>
            <li><strong>Pattern Searching:</strong> Real-world applications in text editors or DNA sequence analysis.</li>
            <li><strong>Graph Algorithms:</strong> Applications in social networks, logistics, and communication networks.</li>
        </ul>
    </div>

    <div class="section">
        <h2>3. Determining the Most Efficient Approach/Design Techniques</h2>
        <ul>
            <li>
                <strong>Time Complexity Analysis:</strong> Start with brute force and optimize incrementally by analyzing time complexity.
            </li>
            <li>
                <strong>Binary Search Tree:</strong> Use AVL or Red-Black Trees for balanced data storage and retrieval. Example algorithm for insertion:
                <pre>
void insert(Node*& root, int value) {
    if (root == nullptr) {
        root = new Node(value);
        return;
    }
    if (value < root->data) {
        insert(root->left, value);
    } else {
        insert(root->right, value);
    }
    root = balance(root);
}
                </pre>
            </li>
            <li>
                <strong>DFS and BFS:</strong> Choose DFS for pathfinding problems and BFS for shortest path in unweighted graphs. BFS algorithm example:
                <pre>
void BFS(Graph& g, int start) {
    queue<int> q;
    vector<bool> visited(g.size(), false);
    q.push(start);
    visited[start] = true;

    while (!q.empty()) {
        int node = q.front();
        q.pop();
        cout << node << " ";

        for (int neighbor : g[node]) {
            if (!visited[neighbor]) {
                q.push(neighbor);
                visited[neighbor] = true;
            }
        }
    }
}
                </pre>
            </li>
            <li>
                <strong>Heap:</strong> Use heaps for implementing efficient priority queues. Example for heapify:
                <pre>
void heapify(vector<int>& heap, int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left < n && heap[left] > heap[largest])
        largest = left;

    if (right < n && heap[right] > heap[largest])
        largest = right;

    if (largest != i) {
        swap(heap[i], heap[largest]);
        heapify(heap, n, largest);
    }
}
                </pre>
            </li>
            <li>
                <strong>Sorting:</strong> Use MergeSort for stability, QuickSort for in-place sorting, and HeapSort for space efficiency. Example of QuickSort:
                <pre>
void quickSort(vector<int>& arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);

        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}
                </pre>
            </li>
            <li>
                <strong>Pattern Searching:</strong> Apply KMP or Rabin-Karp for pattern matching in large datasets efficiently. Example of KMP:
                <pre>
void computeLPSArray(string pattern, int M, int* lps) {
    int len = 0;
    lps[0] = 0;
    int i = 1;

    while (i < M) {
        if (pattern[i] == pattern[len]) {
            len++;
            lps[i] = len;
            i++;
        } else {
            if (len != 0) {
                len = lps[len - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
}
                </pre>
            </li>
            <li>
                <strong>Graph Algorithms:</strong> Use Dijkstra for shortest paths, Prim/Kruskal for MST, and Bellman-Ford for graphs with negative weights. Example of Dijkstra:
                <pre>
void dijkstra(vector<vector<pair<int, int>>>& graph, int src) {
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    vector<int> dist(graph.size(), INT_MAX);

    pq.push({0, src});
    dist[src] = 0;

    while (!pq.empty()) {
        int u = pq.top().second;
        pq.pop();

        for (auto& neighbor : graph[u]) {
            int v = neighbor.first;
            int weight = neighbor.second;

            if (dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                pq.push({dist[v], v});
            }
        }
    }
}
                </pre>
            </li>
        </ul>
    </div>
</body>
</html>
